# ポインタ型を取るtemplateの注意点

## ことの始まり

C++も11になり、14になり、17が見えている。  
スマートポインタという素晴らしい機能を使うことができる時代だ。  
そんなに時代にvectorに生ポインタを突っ込んだ挙句に大量にリークさせた人がいた。  
外部の人のコードなので手を加えることができず、スマートポインタに書き換えることができなかったので、初めてポインタの難しさを感じたので書いておく

## vectorに生ポインタを突っ込むのはヤバい

`vector<int*>`みたいな生ポインタを突っ込むのは個人的にNOである。  
それがスマートポインタと生ポインタの速度差を気にするプロジェクトなら仕方ないが、それはそれで他のアルゴリズムを見直した方がいいのでは？と思っている。  

さて、この`vector<int*>`は何がダメかというと、  

- std::findが使えない  
- std::removeでアドレス指定しないとダメ  
- std::removeでリーク  

まぁ、ここまではパッと分かったことだが、`std::find_if`を使ってポインタを分かってない脳みそだったから詰まってしまった。  

``` C++
std::vector<int*> v;
for( int i = 0; i < 10; ++i){
  v.push_back(new int(i));
} 
```

このvectorが管理しているモノは一体何だろうか？  
答えは、newされた変数のアドレスである。  
つまり、vector自体は連続でも、中に格納されているデータは連続ではないのだ。  

``` C++
auto it = std::find_if( v.begin(), v.end(), [&](int* sample){
  return if(*sample == 0.0);
});
```

Q.このitは何型か？  
A.  
_Vector_iterator<  
  _vector_Val<  
     _Vec_base_types<int*, allocator<int*>>::val_type  
  \>  
\>
  
なげぇよ。  
イテレータ型なんだけど、そのイテレータがさしているのはintのポインタだね？  

``` C++
std::cout << *it << std::endl;
```

Q.出力されるものは何だろう？  
A.0xoooxxxoooなどのアドレス  



