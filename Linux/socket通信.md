# Socket通信

## recv

特徴

- データ受信完了まで、対象ソケットをブロックする

## select系

### select

返り値について

FD集合に残っているFD総数。  
タイムアウトする場合はFD集合は空になるため0を返す。（違うシステムもあるらしい）

`recv`はデータが受信できるまで、対象のソケットをブロックする特徴を持つ。  
この特徴は、ソケットを一つしか利用していない場合には非常に便利であるが、ソケットが複数になると面倒なことを引き起こす。

複数のFDがI/O可能になることを監視する機能。

### pselect

`select`に加えてシグナルを待つ場合に用いられる。  
通常は、シグナルハンドラーをグローバルなフラグを立てるためだけに使う。  
ただし、このグローバルなフラグは、そのイベントをプログラムのメインループで処理しなければならないことを示す。

### selectの掟

1. `select`を使うときはタイムアウトは設定すべきではない。  
   処理するデータがないときには、プログラムは何もすることはない。  
   タイムアウトに依存したコードは通常移植性が無く、デバッグが難航する。
2. 効率的なプログラムを書くには`nfds`の値を適切に計算して与えなければならない。
3. `select`コールの終了後に結果をチェックして、適切に対応するつもりのないFDは、どの集合にも加えてはならない。
4. `select`から帰った後には、全ての集合の全FDについて読み書き可能な状態になっているかチェックすべき。
5. `read(2)`/`recv(2)`/`write(2)`/`send(2)`は、こちらが要求した全データを読み書きする必要はない。  
   全データを読み書きするのは、トラフィック負荷が小さく、ストリームが速い場合に限定される。  
   これらの関数がどう足掻いても1byteしか送受信できない場合も考慮に入れて実装すること。
6. 処理するデータ量が小さいことが明確な場合を除いて、1byteずつ読み書きするようなことはNG。  
   バッファの限界までまとめて読み書きすることが最も効率が良い。
7. `read(2)`/`recv(2)`/`write(2)`/`send(2)`の関数や`select`がエラー(-1)を返却する場合は、その種類を`errno`変数に格納する。  
   これらの内容には適切に対応する必要がある。
     - EINTR
     - EAGAIN
     - EWOULDBLOCK
8. 決して、長さ0のバッファを`read(2)`/`recv(2)`/`write(2)`/`send(2)`に渡してはならない。
9. `read(2)`/`recv(2)`/`write(2)`/`send(2)`が7.に示した以外のエラーや入力系関数がファイルの末尾を示す0を返した場合は、そのFDをもう一度`select`に渡してはならない。  
   そのFDは直ちにクローズ、-1がセットされ、どの集合にも含まれることを許してはならない。
10. タイムアウト値は`select`を呼ぶたびに初期化すべきである。  
    OSによってはtimeout構造体が変更される場合があるため、それによる挙動変化を防止するためである。  
    > ただし、`pselect`は自身のtimeout構造体を変更することはない。
11. `select`はFD集合を変更するため、`select`がループ内で私用されている場合には、呼び出しを行う前に魔界FD集合を初期化する必要がある。

## accept
