# UUIDを主キーにする

[田中ひさてる@tanakahisateru](https://x.com/tanakahisateru/status/1942601284386779172)

> UUIDを主キーにするデメリット、順序がないため、近いデータが連続したキャッシュに入りにくいとかでのパフォーマンス問題は語られるけど、今日あったのは、全件バッチのカーソルを次へ次へと送るやつで、各行フェッチ時の次の位置情報だけで、帯域埋まってボトルネックになるぐらい肥大化したこと  
> 単純な int キーのときと比べて、どのCPUもアイドルだらけ、結果スループットが全然出ない、という有様なのに、DBとSQL発行したマシンとの間の通信量がおそらく天井ってぐらいパンパンになっていた  
> もとが分散書き込みのデータでも、集めて直列でRDB(MySQL)に入れるときは、サロゲート主キーをintで付けておくのがよくて、UUIDは単なるユニークな名前として扱い、ランダムアクセス用にインデックス付けておくとかにしておくのがよさそう

## ❌ UUIDを主キーにすることで起こった問題

### 1. **データサイズ（通信量）の肥大化**

* バッチで全件カーソルフェッチをする処理で、主キー（UUID）が大きいため「次の位置情報（カーソルのポインタ）」を返すたびに通信量が大きくなり、**DBとアプリケーション間の帯域がボトルネックになった**。
* `int` の主キーであれば数バイトで済むが、UUID（16バイト／36文字文字列として扱うともっと）はそれだけで**帯域を圧迫**。

#### 2. **CPUは暇しているのにスループットが出ない**

* ネットワーク帯域が詰まる一方で、CPUやDBはリソースを持て余していて**リソースが偏った状態**に。
* つまり、**ボトルネックがネットワークIOに集中**する非効率な状況。

#### 3. **キャッシュの非効率利用**

* UUIDはランダムで順序性がないため、**挿入順が物理的なデータ配置に影響しにくく、キャッシュやインデックス効率が悪化**。

---

## ✅ 提案されたベストプラクティス

* 書き込み元が分散されていても、**RDBに保存する段階では `int` のサロゲートキーを使う**。
* UUIDは**外部参照用のユニーク識別子として別カラムに保存**し、必要に応じてインデックスを貼る。
* こうすることで、

  * カーソルベースのバッチ処理が軽くなる
  * ネットワーク帯域を無駄にしない
  * キャッシュ効率も良くなる
  * インデックスも効率的

---

## 🧠 補足すると

この問題は**実装だけでなく設計レベルの判断**にも直結していて、特に以下のような場合に気をつけるべきです：

* **大量データをバッチで読む処理**がある場合
* **順序処理や時間軸に沿ったデータ取得が多い**場合
* **DBとアプリケーション間の帯域が細い**場合（クラウド間通信やオンプレ→クラウド）

---

## 📌 まとめ

UUIDを主キーにするのは便利ではあるものの、

* 性能面
* 通信効率
* キャッシュ効率
* スループット全体への影響

などを考えると、「単なるユニーク名として使い、主キーは順序性のある `int` にする」のがやはり実戦的なアーキテクチャです。
このツイートはその実際の落とし穴を非常にうまく言語化している良ポストですね。

---

もしご希望あれば、この内容を元に簡潔な技術ブログやQiita記事向けにもまとめ直せます。
