# sshよもやま話

## sshの生存確認パケット

`ssh`コマンドは通常、サーバー側の`sshd`設定値以内に生存確認パケットを送らない限りタイムアウトで強制切断する仕組みになっている。

```bash
$ ssh hoge
(hoge)#
Write failed: Broken pipe
$
```

`sshd`側の設定で変更することもできるが、クライアント側の設定を紹介する。

```.ssh/config
TCPKeepAlive yes
ServerAliveInterval 60 #単位：sec
ServerAliveCountMax 60 #単位：回数
```

`ServerAliveInterval`で設定した秒数が経過後、`KeepAlive`パケットを送信する。  
`ServerAliveCountMax`は設定した許容回数の閾値で、この閾値以上、連続して`KeepAlive`パケットが送信された場合は`ssh`セッションを切断する。  
この値はあくまで「連続して送信した」回数であり、別のパケットを送信した場合はその時点で0に上書きされる。

よって、以上の設定の意味は以下になる。  
「60秒に1回だけ生存パケットを送信し、連続して60回の生存パケット送信をすれば`ssh`セッションを切断する」

この設定で注意するべきはサーバー側のsshd設定である。  
仮に、上記の設定が行われていたとしても、sshd設定が「5秒以内のKeepAliveで12回連続した場合に切断」という設定が書かれていたとする。  
この場合、サーバー側の切断条件がクライアントの切断条件より厳しいため、サーバーからsshセッションを切断されてしまう。  
サーバー側よりも厳しい閾値を設定する必要がある。

## sshは切断時挙動

`ssh`コマンドの接続が切れた時、動かしていたプロセスが停止する問題に遭遇した。

Linuxは`logout`時に、そのユーザーに紐づくプロセスに`SIGHUP`シグナルを送信する仕組みになっている。  
こうすることで、存在しないユーザーのプロセスは動かないようになっている。  
これはバックグラウンドプロセス（`&`付き実行）でも同じである。

`ssh`の切断時には`logout`が実行される。  
さらに、`ssh`はサーバーの設定値以内にクライアントが生存確認通信を行わない限り`ssh`接続を強制的に切断する仕組みになっている。

そこで、通常`ssh`接続を維持したままコマンドを実行し続けるには`nohup`コマンドを用いる。

```bash
$ nohup command --option &> ./command.log &
```

`stdout`や`stderr`にログを出力していると`logout`時に標準出力などを手放してしまうため再ログイン時にログを確認できない。そのため、ファイルにリダイレクトしておくこと。
