# Linuxの仕組み

これは何をしてるマークダウン？  
「Linuxの仕組み」を読んで、分かってなかったことを中心にまとめる。

## コンピューターシステムの概念

デバイス制御

OSがない場合でのデバイス制御は、各プロセスが直接デバイス操作処理を行う。  
こうなると各アプリケーションに制御コードが散乱してしまいメンテ難度が上がる。
また、デバイスに同時アクセスしてしまった際の挙動など予期せぬ動作が増えるし、そういった問題をクリアするためにアプリ層のエンジニアにハードウェア層の知識が必要になり、アプリ制作のハードルが一気に高くなってしまう。  

デバイスドライバ（通称、デバドラ）

そこで搭乗するのがデバイスドライバというデバイス制御を一挙に引き受けてくれるソフトウェアである。  
これは大まかな種類に分けて存在する。

- I/Oデバイスドライバ……I/Oデバイスの共通処理と商品固有の処理を持つ
- ストレージデバイスドライバ……ストレージデバイスの共通処理と商品固有の処理を持つ
- ネットワークアダプタドライバ……ネットワークアダプタの共通処理と商品固有の処理を持つ

カーネルモードの存在意義とは？

あるプロセスが、バグや悪意によって「**デバイスにはデバイスドライバを介しなければならない**」というルールを破った場合どうなるか？  
複数のプロセスが同時にデバイスを操作するという問題の状況が発生してしまう。  
しかし、性善説でやるには破られた場合のリスクが大きく、やはり、未然に防ぐための制度が必要であった。  
これがカーネルモードの生まれた経緯である。

カーネルとユーザー

- カーネルモード  
  主にデバイスを制御するモードだが、通常のプロセスから実行してはいけない厳格なモードと言える。  
  - プロセス管理システム
  - プロセススケジューラ
  - メモリ管理システム
- ユーザーモード  
  プロセスを制御するモード

カーネル

カーネルモードで動くOSの核となる処理のまとまりを**カーネル**と呼ぶ。  
プロセスがデバイスドライバを含めたカーネルが提供する機能を使いたければ、すべて**システムコール**と呼ばれる特殊な処理を介してカーネルに依頼する必要がある。

## ユーザーモードで実現する機能

システムコール

各種プロセスは、プロセス生成、ハードウェア制御などのカーネルの助けが必要になるときにはシステムコールという種d何位依ってカーネルに処理を依頼する。

- プロセス生成、削除
- メモリ確保、解法
- プロセス間通信
- ネットワーク
- ファイルシステム操作
- ファイル操作（デバイスアクセス）

CPUのモード遷移

システムコールはCPUの特殊な命令を実行することで発行する。  

1. 実行するシステムコールを指定する番号をレジスタにセット
2. システムコールに渡す引数をレジスタにセット
3. システムコールを発動するインストラクション/命令文を実行する

プロセスは基本的にはユーザーモードで動作しているが、システムコールを発行するとCPUにおいて**割込み**というイベントが発生します。これによってCPUはユーザーモードからカーネルモードに遷移して、依頼内容に応じたカーネル処理を実行し、それが終わればまたユーザーモードに復帰する。

> カーネルとして動くから、割込み処理中はprintf系のユーザー出力関数が使用できない。

カーネルは処理の冒頭で**プロセスからの要求が正当か？**をチェックし、不正なら失敗させます。

> たとえば、システム管理外のメモリを要求していないかとか。

当然、ユーザープロセスからシステムコールを介さずに直接CPUのモードを変更する方法はない。

## プロセス管理

実際は仮想記憶システムの知識が必須なので、それがない簡易版を解説。

プロセスを生成する方法

- `fork`  
  同じプログラムの処理を複数のプロセスに分けて処理する。  
  動いているプロセスのメモリマップを新しいアドレスにコピーして初期化して実行する方法。
  > Webサーバーによる複数のリクエスト受付
  > [fork()は失敗するんだぜ、覚えときな](https://cpplover.blogspot.com/2014/08/fork.html)  
  > [fork() can fail: this is important](http://rachelbythebay.com/w/2014/08/19/fork/)
- `execve`  
  別のプログラムを生成する。  
  動かしたプロセス（`exec()`など）のメモリマップを新しいアドレスにコピーした後、別の実行ファイルを読み出し新しいプロセスで上書きする方法。  
  `execve`はプロセスを開始することしか出来ないので、必然的に`fork`&`execve`の組み合わせで実現する。
  > bashから各種プログラムを新規生成

プロセスを終了する方法

`_exit()`関数を使って`exit_group`システムコールを発呼することで行われる。  
当該プロセスに割り当てられていたメモリ（恐らくfdも）をすべて回収する。
これは`main`関数から復帰した場合も実行される。

## プロセススケジューラ

Linuxは複数のプロセスを同時に動作させる（ように見せている）ために**プロセススケジューラ**機能を持つ。  
普段はこの仕組みは意識しなくてもいいように作られているが、これを理解することでスケジューラへの理解を深める。

コンテキストスイッチ

論理CPU上で動作するプロセスが切り替わることを示す。  
プロセスがいうかなるコードを実行中でもタイムスライスが切れるとコンテキストスイッチが発生する。

プロセスの状態

以下のコードでLinux上で動いているプロセス数を知ることができる。

```bash
$ ps ax | wc -l
```

schedプログラム以外のプログラムはどうなっていたのかというと**スリープ状態**になっている。

|状態|意味|
|:--:|:--|
|実行状態|現在論理CPUを使っている|
|実行待ち状態|CPU時間が割り当てられるのを待っている|
|スリープ状態|なんらかのイベント発生待ちで、イベント発生までCPU時間は消費しない|
|ゾンビ状態|プロセスが終了した後に親プロセスが終了状態を受け取るのを待っている|

スリープで待っているイベントは？

- 所定時間（3分間待つなど）
- ユーザー入力（キーボード、マウスなど）
- ストレージデバイスへの読み書き終了
- ネットワークによるデータの送受信終了待ち（selectとかrecvとか？）

スループットとレイテンシ

- Throughput  
  単位時間当たりの総仕事量。高いほどいい。  
  今は「完了したプロセス数 / 経過時間」で良いとする。
- Latency  
  各処理の開始から終了までの時間。短いほどいい。  
  「終了処理時刻 - 処理開始時刻」で良いとする。

## メモリ管理

## 記憶階層

## ファイルシステム

## ストレージデバイス
