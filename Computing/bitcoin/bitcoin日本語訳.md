# ビットコイン

## 要約

完全にピア・ツー・ピア（P2P）型の電子通貨の仕組みは、金融機関を介さずに、当事者同士が直接オンラインで支払いを送受信できるようにするものである。  
デジタル署名はこの仕組みの一部を解決するが、二重支払い（double-spending）を防ぐために信頼できる第三者が必要であるなら、その主要な利点は失われてしまう。  

私たちは、ピア・ツー・ピアネットワークを用いた二重支払い問題の解決方法を提案する。  
このネットワークは、取引をハッシュ化して連続する「ハッシュベースのプルーフ・オブ・ワーク（Proof-of-Work）」の鎖に組み込み、時刻を記録する。  
これにより、過去の記録を改ざんするには、そのプルーフ・オブ・ワークをやり直さなければならないため、改ざんが実質的に不可能になる。  

最も長い鎖は、観測された出来事の時系列を証明するだけでなく、最も多くのCPUパワーを投入した集合体によって生成されたことの証明にもなる。  
ネットワーク上のCPUパワーの過半数が攻撃者と協調しないノードにより支配されている限り、彼らが最も長い鎖を生成し、攻撃者を上回ることができる。  

このネットワーク自体は最小限の構造しか必要としない。  
メッセージはベストエフォートでブロードキャストされ、ノードは自由にネットワークを離脱・再参加できる。  
ノードが不在の間に何が起きたかは、最も長いプルーフ・オブ・ワークの鎖を受け入れることで確認できる。  

## 1. 導入

インターネット上の商取引は、電子決済を処理するための信頼できる第三者として、金融機関にほぼ完全に依存してきた。  
この仕組みは多くの取引において十分に機能しているが、「信頼に基づくモデル」に内在する弱点を免れることはできない。  

完全に取り消し不能な取引を実現することは実質的に不可能である。  
なぜなら、金融機関は取引上の紛争を仲裁する役割を避けられないためである。  
この仲裁コストは取引コストを増大させ、実用的に成立する最小取引額を制限し、少額のカジュアルな取引の可能性を断ち切ってしまう。  
さらに、取り消し不可能なサービスに対して取り消し不可能な支払いを行う能力が失われるという、より広範なコストも生じる。  

取引が取り消される可能性があるために、信頼の必要性が広がる。  
販売者は顧客を疑わざるを得ず、通常なら不要なほどの情報提供を求めることになる。  
ある程度の詐欺発生は「避けられないもの」として受け入れられている。  
こうしたコストや支払いの不確実性は、 **現金（物理的通貨）** を使えば対面取引で回避できるが、通信経路を介して、信頼できる第三者なしに支払いを行う仕組みは存在しなかった。  

信頼ではなく **暗号的証明（cryptographic proof）** に基づく電子決済システムが必要である。  
これにより、信頼できる第三者を必要とせずに、任意の2者が直接取引を行うことが可能になる。  
計算的に取り消しが不可能な取引は販売者を詐欺から保護し、 **エスクロー（第三者預託）** のような仕組みも、購入者保護のために容易に実装できる。  

本論文では、ピア・ツー・ピア型の分散タイムスタンプサーバーを用いて、取引の時系列順序を **計算による証明（computational proof）** として生成することで、二重支払い問題を解決する手法を提案する。  

このシステムは、誠実なノードが協調する攻撃ノード群よりも多くのCPUパワーを保持している限り、安全に機能する。  

## 2. 取引

電子コインを、デジタル署名の連鎖として定義する。  
各所有者は、前の取引のハッシュと次の所有者の公開鍵にデジタル署名を行い、それらをコインの末尾に追加することで、コインを次の所有者に移転する。  
受取人は署名を検証することで、所有権の連鎖を確認できる。  

もちろん問題は、受取人がそのコインが前の所有者によって二重支払いされていないことを確認できない点である。  
一般的な解決策は、すべての取引を二重支払いの観点から確認する、信頼できる中央管理者（ミント）を導入することである。  
各取引の後、コインは新しいコインを発行するためにミントに返却されなければならず、ミントから直接発行されたコインのみが二重支払いされないと信頼される。  
しかし、この解決策の問題点は、通貨システム全体の運命がミントを運営する会社に依存し、すべての取引が銀行と同じようにそこを経由しなければならないことである。  

受取人が前の所有者が以前の取引に署名していないことを確認できる方法が必要である。  
私たちの目的では、最も早い取引のみが有効であり、その後の二重支払いの試みは問題にならない。  
ある取引が存在しないことを確認する唯一の方法は、すべての取引を把握することである。  
ミント型モデルでは、ミントがすべての取引を把握し、どの取引が先に行われたかを判断していた。  
信頼できる第三者なしでこれを実現するには、取引を公開する必要があり [1]、参加者全員が取引の受領順序について単一の履歴で合意する仕組みが必要である。  
受取人は、各取引が行われた時点で、ノードの過半数がそれが最初に受領された取引であることに同意していたという証明を必要とする。  

## 3. タイムスタンプサーバ

私たちが提案する解決策は、タイムスタンプサーバから始まる。  
タイムスタンプサーバは、タイムスタンプを付けたいデータのブロックをハッシュ化し、そのハッシュを新聞やニュースグループの投稿などで広く公開することで機能する [2-5]。  
タイムスタンプは、そのデータがその時点で存在していたことを証明する。  なぜなら、ハッシュに含めるためにはデータがすでに存在している必要があるからである。  
各タイムスタンプは、前のタイムスタンプを自分のハッシュに含めることで連鎖を形成し、追加されるタイムスタンプごとに以前のものがさらに強化される。  

## 4. プルーフ・オブ・ワーク

ピア・ツー・ピア型で分散タイムスタンプサーバを実現するためには、新聞やニュースグループの投稿ではなく、Adam Back の Hashcash [6] に似たプルーフ・オブ・ワーク（Proof-of-Work）システムを使用する必要がある。  

プルーフ・オブ・ワークでは、ハッシュ化したときに（例えば SHA-256 で）ハッシュの先頭に一定数のゼロビットが並ぶ値を探す作業が行われる。  必要なゼロビットの数に応じて平均的な計算量は指数関数的に増加するが、検証は単一のハッシュ計算で可能である。  

タイムスタンプネットワークでは、ブロック内のノンス（nonce）を増加させながら、ブロックのハッシュが必要なゼロビットを満たす値を見つけることでプルーフ・オブ・ワークを実装する。  CPUによる計算努力を費やしてプルーフ・オブ・ワークを満たすと、そのブロックは作業をやり直さない限り変更できなくなる。  さらに後続のブロックが連鎖しているため、そのブロックを変更するには後続のすべてのブロックもやり直さなければならない。  

プルーフ・オブ・ワークは、過半数決定における代表権の問題も解決する。  もし過半数を「IPアドレス1つにつき1票」で決めると、多数のIPを確保できる者によって操作される可能性がある。  しかし、プルーフ・オブ・ワークでは基本的に「CPU 1台につき1票」となる。  過半数決定は、最も長い鎖によって表され、そこには最も大きなプルーフ・オブ・ワークの努力が投入されている。  
正直なノードがCPUパワーの過半数を占めている場合、正直な鎖が最も速く伸び、競合する鎖を上回る。  過去のブロックを改ざんしようとする攻撃者は、そのブロックと後続のすべてのブロックのプルーフ・オブ・ワークをやり直し、正直なノードの作業量に追いつき、さらに上回らなければならない。  後続のブロックが追加されるごとに、遅い攻撃者が追いつく確率は指数関数的に減少することを後で示す。  

また、ハードウェアの高速化やノード運用への関心の変化に対応するため、プルーフ・オブ・ワークの難易度は、1時間あたりのブロック生成数の平均を目標にした移動平均で決定される。  ブロックが生成される速度が速すぎる場合は、難易度が上がる。  

## 5. ネットワーク

ネットワークを運用する手順は次の通りである。  

1. 新しい取引はすべてのノードにブロードキャストされる。  
2. 各ノードは新しい取引をブロックにまとめる。  
3. 各ノードは自分のブロックに対して難しいプルーフ・オブ・ワークを見つける作業を行う。  
4. ノードがプルーフ・オブ・ワークを見つけると、そのブロックをすべてのノードにブロードキャストする。  
5. ノードは、ブロック内のすべての取引が有効であり、既に使用されていない場合に限り、そのブロックを受け入れる。  
6. ノードは、受け入れたブロックのハッシュを前のハッシュとして使用し、次のブロックの作成作業を行うことで、そのブロックを受け入れたことを示す。  

ノードは常に最も長い鎖を正しいものと見なし、それを延長する作業を続ける。  
もし二つのノードが同時に異なる次のブロックをブロードキャストした場合、あるノードはどちらか一方を先に受け取ることになる。  
その場合、最初に受け取った方のブロックで作業を行い、もう一方のブロックは将来長くなる可能性を考慮して保存する。  
この「同点」は次のプルーフ・オブ・ワークが見つかり、どちらかの鎖が長くなることで解消される。  
他方の鎖で作業していたノードは、その時点で長い鎖に切り替える。  

新しい取引のブロードキャストは必ずしもすべてのノードに届く必要はない。  
多くのノードに届けば、やがてブロックに組み込まれる。  
ブロックのブロードキャストも、メッセージが欠落しても耐性がある。  
もしノードがブロックを受け取れなかった場合、次のブロックを受け取った時に前のブロックが欠落していたことに気づき、要求することで補完できる。  

## 6. インセンティブ

慣例として、ブロック内の最初の取引は特別な取引であり、ブロックを作成した者が新しいコインを所有する形になっている。  
これにより、ノードがネットワークを支援する動機が生まれ、中央管理者が存在しない状況でもコインを初期に流通させる方法が提供される。  
一定量の新しいコインが継続的に追加される仕組みは、金鉱山労働者が資源を費やして金を流通させることに似ている。  
ここで費やされるのは、CPU時間と電力である。  

インセンティブは取引手数料によっても賄うことができる。  
取引の出力額が入力額より少ない場合、その差額は取引手数料となり、その取引を含むブロックのインセンティブに加えられる。  
一定数のコインが流通に出ると、インセンティブは完全に取引手数料に移行でき、インフレの心配はなくなる。  

このインセンティブは、ノードが正直であり続ける動機付けにもなる。  
もし強欲な攻撃者が正直なノード全体よりも多くのCPUパワーを持っていたとしても、そのCPUパワーを使って人々から支払いを盗み取るか、新しいコインを生成するかの選択を迫られる。  
正直にルールに従う方が、システムを破壊して自分の資産の有効性を損なうよりも利益が大きいことが多い。  
なぜなら、そのルールでは攻撃者は他のすべての者を合わせた以上の新しいコインを得ることができるからである。  

## 7. ディスク容量の回収

コインの最新の取引が十分な数のブロックに埋もれた場合、それ以前に使用された取引はディスク容量を節約するために破棄できる。  
ブロックのハッシュを壊さずにこれを行うために、取引はマークルツリー（Merkle Tree）[7][2][5] でハッシュ化され、ブロックのハッシュにはツリーのルートのみが含まれる。  
古いブロックは、ツリーの枝を切り詰めることで圧縮できる。  内部のハッシュは保存する必要はない。  

取引が含まれないブロックヘッダーは、約80バイトになる。  
ブロックが10分ごとに生成されると仮定すると、80バイト × 6 × 24 × 365 = 年間約4.2MB となる。  
2008年時点で一般的にコンピュータは2GBのRAMを搭載しており、ムーアの法則に従って年間1.2GBずつ増加すると予測されるため、ブロックヘッダーをメモリに保持する場合でも、ストレージの問題はほとんどない。  

## 8. 簡易支払い検証

フルノードを稼働させなくても、支払いの検証は可能である。  
ユーザーは、最長のプルーフ・オブ・ワーク鎖のブロックヘッダーのコピーだけを保持すればよい。  
このコピーは、ネットワークノードに問い合わせて、最長鎖を取得したと確認できるまで取得することができる。  
さらに、取引をタイムスタンプされたブロックに結びつけるマークルブランチを取得する。  
ユーザー自身で取引内容を確認することはできないが、鎖の位置にリンクすることで、ネットワークノードがその取引を受け入れたことを確認できる。  
その後に追加されたブロックは、ネットワークがその取引を受け入れたことをさらに裏付ける。  

このように、正直なノードがネットワークを支配している限り、検証は信頼できる。  
しかし、攻撃者がネットワークを圧倒している場合には、簡易検証はより脆弱になる。  
ネットワークノードは自身で取引を検証できるが、簡易検証では、攻撃者が作成した偽の取引に騙される可能性がある。  
この攻撃に対抗する一つの方法は、ネットワークノードが無効なブロックを検出した際に警告を送ることを受け入れ、ユーザーのソフトウェアがそのブロックと警告された取引をダウンロードして不整合を確認することである。  
頻繁に支払いを受ける企業は、より独立したセキュリティと迅速な検証のために、自社でノードを運用したいと考えるだろう。  

## 9. 価値の結合と分割

コインを個別に扱うことも可能ではあるが、送金のたびに1セントごとに別々の取引を行うのは煩雑である。  
価値を分割・結合できるようにするため、取引には複数の入力と出力を含めることができる。  
通常は、前の大きな取引からの単一入力か、複数の小額の入力を組み合わせたものとなり、出力は最大で2つ：支払い用と、お釣りがある場合は送信者に戻すためのものとなる。  

ここで注意すべき点は、ある取引が複数の取引に依存し、それらの取引がさらに多くの取引に依存する「ファンアウト（fan-out）」であっても、問題にはならないということである。  
取引履歴の完全な独立コピーを取り出す必要は、決してない。  

## 10. プライバシー

従来の銀行モデルでは、関係者と信頼できる第三者だけが情報にアクセスできることで、一定のプライバシーが保たれている。  
すべての取引を公開する必要があるため、この方法は使えないが、別の場所で情報の流れを断つことでプライバシーを保つことは可能である。  
具体的には、公開鍵を匿名に保つことである。  
誰かが誰かに送金していることは公に見えるが、その取引を誰に結びつけるかの情報はない。  
これは株式取引所が公開する情報に似ており、個別取引の時間や規模（「テープ」）は公表されるが、取引当事者が誰であるかは明かされない。  

さらにプライバシーを強化するため、各取引ごとに新しい鍵ペアを使用し、共通の所有者にリンクされないようにするべきである。  
ただし、複数入力の取引では、入力が同一の所有者によるものであることが必然的に明らかになるため、ある程度のリンクは避けられない。  
鍵の所有者が判明した場合、そのリンクをたどることで、同一所有者による他の取引が明らかになるリスクがある。  

## 11. 計算

攻撃者が正直な鎖よりも早く別の鎖を生成しようとする場合を考える。  
たとえそれが成功したとしても、システムは恣意的な改変、例えば無から価値を生み出したり、攻撃者に元々属さない資金を奪うことは許さない。  
ノードは無効な取引を支払いとして受け入れず、正直なノードはそれを含むブロックを決して承認しない。  
攻撃者ができることは、自分が最近支払った取引の一つを変更してお金を取り戻そうとすることだけである。  

正直な鎖と攻撃者の鎖との競争は、二項ランダムウォーク（Binomial Random Walk）として表すことができる。  
成功イベントは正直な鎖が1ブロック延長され、リードが +1 増えること。  
失敗イベントは攻撃者の鎖が1ブロック延長され、差が -1 減ることである。  

攻撃者がある差を追いつく確率は、ギャンブラーの破産問題（Gambler's Ruin）に類似している。  
無限の信用を持つギャンブラーが、赤字からスタートしてブレイクイーブンに到達するまで無限の試行を行う場合を考える。  
同様に、攻撃者が正直な鎖に追いつく確率を次のように計算できる [8]。  

前提として p > q と仮定すると、攻撃者が追いつく必要のあるブロック数が増えるほど、その確率は指数関数的に減少する。  
もし初期段階で運良くリードできなければ、差が広がるにつれて成功の可能性はほぼゼロに近づく。  

次に、新しい取引の受取人が、送信者が取引を変更できないと十分に確信するまでどれくらい待つ必要があるかを考える。  
送信者は攻撃者であり、最初は受取人に支払いを行ったと思わせた後、ある時間が経過した後に自分に返金するように変更しようとする。  
受取人はそれが発覚した時点で警告を受けるが、送信者はそれが手遅れになることを期待する。  

受取人は新しい鍵ペアを生成し、署名直前に公開鍵を送信者に渡す。  
これにより、送信者が事前にブロックの鎖を作成して先行して進め、運良く十分先に進んだ時点で取引を実行することを防ぐ。  
取引が送信されると、不正な送信者は秘密裏に、自分の取引の別バージョンを含む並行鎖の作成を開始する。  

受取人は、取引がブロックに追加され、その後 z 個のブロックが連鎖されたことを確認するまで待つ。  
攻撃者の進捗量は正確には分からないが、正直なブロックが平均的な時間で生成されたと仮定すると、攻撃者の潜在的進捗はポアソン分布に従い、期待値は以下の通りとなる。  

攻撃者が追いつける確率を求めるには、攻撃者が達成し得る進捗量ごとのポアソン密度に、そこから追いつく確率を掛け合わせる。  
分布の無限尾を合計せずに整理すると…

## 12. 結論

私たちは、信頼に依存せずに電子取引を行うためのシステムを提案した。  
まず、デジタル署名で構成されたコインという従来の枠組みから始めた。  これにより所有権を強力に管理できるが、二重支払いを防ぐ仕組みがなければ不完全である。  
この問題を解決するために、プルーフ・オブ・ワークを用いたピア・ツー・ピアネットワークを提案した。  これにより、取引の公開履歴が記録され、正直なノードがCPUパワーの過半数を支配していれば、攻撃者が変更するのは計算上ほぼ不可能になる。  

ネットワークは、その非構造的でシンプルな設計により堅牢である。  
ノードはほとんど協調せずに同時に作業を行う。  
ノードを特定する必要はなく、メッセージは特定の場所にルーティングされず、ベストエフォートで届けられれば十分である。  
ノードは自由にネットワークを離脱・再参加でき、プルーフ・オブ・ワークの鎖をその間に起きた出来事の証拠として受け入れる。  
ノードはCPUパワーを使って投票し、有効なブロックを承認する場合はそれを延長する作業を行い、無効なブロックは作業を拒否することで拒否する。  
必要なルールやインセンティブも、このコンセンサス機構によって実行できる。  
