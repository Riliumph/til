# Linuxの仕組み

これは何をしてるマークダウン？  
「Linuxの仕組み」を読んで、分かってなかったことを中心にまとめる。

## 1.コンピューターシステムの概念

### デバイス制御

OSがない場合でのデバイス制御は、各プロセスが直接デバイス操作処理を行う。  
こうなると各アプリケーションに制御コードが散乱してしまいメンテ難度が上がる。
また、デバイスに同時アクセスしてしまった際の挙動など予期せぬ動作が増えるし、そういった問題をクリアするためにアプリ層のエンジニアにハードウェア層の知識が必要になり、アプリ制作のハードルが一気に高くなってしまう。  

### デバイスドライバ（通称、デバドラ）

そこで搭乗するのがデバイスドライバというデバイス制御を一挙に引き受けてくれるソフトウェアである。  
これは大まかな種類に分けて存在する。

- I/Oデバイスドライバ……I/Oデバイスの共通処理と商品固有の処理を持つ
- ストレージデバイスドライバ……ストレージデバイスの共通処理と商品固有の処理を持つ
- ネットワークアダプタドライバ……ネットワークアダプタの共通処理と商品固有の処理を持つ

### カーネルモードの存在意義とは？

あるプロセスが、バグや悪意によって「**デバイスにはデバイスドライバを介しなければならない**」というルールを破った場合どうなるか？  
複数のプロセスが同時にデバイスを操作するという問題の状況が発生してしまう。  
しかし、性善説でやるには破られた場合のリスクが大きく、やはり、未然に防ぐための制度が必要であった。  
これがカーネルモードの生まれた経緯である。

### カーネルとユーザー

- カーネルモード  
  主にデバイスを制御するモードだが、通常のプロセスから実行してはいけない厳格なモードと言える。  
  - プロセス管理システム
  - プロセススケジューラ
  - メモリ管理システム
- ユーザーモード  
  プロセスを制御するモード

### カーネル

カーネルモードで動くOSの核となる処理のまとまりを**カーネル**と呼ぶ。  
プロセスがデバイスドライバを含めたカーネルが提供する機能を使いたければ、すべて**システムコール**と呼ばれる特殊な処理を介してカーネルに依頼する必要がある。

## 2.ユーザーモードで実現する機能

### システムコール

各種プロセスは、プロセス生成、ハードウェア制御などのカーネルの助けが必要になるときにはシステムコールという種d何位依ってカーネルに処理を依頼する。

- プロセス生成、削除
- メモリ確保、解法
- プロセス間通信
- ネットワーク
- ファイルシステム操作
- ファイル操作（デバイスアクセス）

### CPUのモード遷移

システムコールはCPUの特殊な命令を実行することで発行する。  

1. 実行するシステムコールを指定する番号をレジスタにセット
2. システムコールに渡す引数をレジスタにセット
3. システムコールを発動するインストラクション/命令文を実行する

プロセスは基本的にはユーザーモードで動作しているが、システムコールを発行するとCPUにおいて**割込み**というイベントが発生します。これによってCPUはユーザーモードからカーネルモードに遷移して、依頼内容に応じたカーネル処理を実行し、それが終わればまたユーザーモードに復帰する。

> カーネルとして動くから、割込み処理中はprintf系のユーザー出力関数が使用できない。

カーネルは処理の冒頭で**プロセスからの要求が正当か？**をチェックし、不正なら失敗させます。

> たとえば、システム管理外のメモリを要求していないかとか。

当然、ユーザープロセスからシステムコールを介さずに直接CPUのモードを変更する方法はない。

## 3.プロセス管理

実際は仮想記憶システムの知識が必須なので、それがない簡易版を解説。

### プロセスを生成する方法

- `fork`  
  同じプログラムの処理を複数のプロセスに分けて処理する。  
  動いているプロセスのメモリマップを新しいアドレスにコピーして初期化して実行する方法。
  > Webサーバーによる複数のリクエスト受付
  > [fork()は失敗するんだぜ、覚えときな](https://cpplover.blogspot.com/2014/08/fork.html)  
  > [fork() can fail: this is important](http://rachelbythebay.com/w/2014/08/19/fork/)
- `execve`  
  別のプログラムを生成する。  
  動かしたプロセス（`exec()`など）のメモリマップを新しいアドレスにコピーした後、別の実行ファイルを読み出し新しいプロセスで上書きする方法。  
  `execve`はプロセスを開始することしか出来ないので、必然的に`fork`&`execve`の組み合わせで実現する。
  > bashから各種プログラムを新規生成

### プロセスを終了する方法

`_exit()`関数を使って`exit_group`システムコールを発呼することで行われる。  
当該プロセスに割り当てられていたメモリ（恐らくfdも）をすべて回収する。
これは`main`関数から復帰した場合も実行される。

## 4.プロセススケジューラ

Linuxは複数のプロセスを同時に動作させる（ように見せている）ために**プロセススケジューラ**機能を持つ。  
普段はこの仕組みは意識しなくてもいいように作られているが、これを理解することでスケジューラへの理解を深める。

### コンテキストスイッチ

論理CPU上で動作するプロセスが切り替わることを示す。  
プロセスがいうかなるコードを実行中でもタイムスライスが切れるとコンテキストスイッチが発生する。

### プロセスの状態

以下のコードでLinux上で動いているプロセス数を知ることができる。

```bash
$ ps ax | wc -l
```

schedプログラム以外のプログラムはどうなっていたのかというと**スリープ状態**になっている。

|状態|意味|
|:--:|:--|
|実行状態|現在論理CPUを使っている|
|実行待ち状態|CPU時間が割り当てられるのを待っている|
|スリープ状態|なんらかのイベント発生待ちで、イベント発生までCPU時間は消費しない|
|ゾンビ状態|プロセスが終了した後に親プロセスが終了状態を受け取るのを待っている|

### スリープで待っているイベントは？

- 所定時間（3分間待つなど）
- ユーザー入力（キーボード、マウスなど）
- ストレージデバイスへの読み書き終了
- ネットワークによるデータの送受信終了待ち（selectとかrecvとか？）

### スループットとレイテンシ

- Throughput  
  単位時間当たりの総仕事量。高いほどいい。  
  今は「完了したプロセス数 / 経過時間」で良いとする。
- Latency  
  各処理の開始から終了までの時間。短いほどいい。  
  「終了処理時刻 - 処理開始時刻」で良いとする。

### nice値

特定のプロセスの優先度を変更するniceが制御する値。  
優先度を-19～20することができる

> nice値は小さければ小さいほど優先度が高い

## 5.メモリ管理

### Linuxのメモリフィールドの種類

- total: システムに搭載されている全メモリ
- free: 未使用領域のメモリ
- buff/cache: 最近のOSなら、Buffers + Cached + Slab
- available: free領域 + Kernel内の開放可能領域

### Out Of Memory

メモリの空き領域が少なくなってくるとKernel内の開放可能メモリ領域を開放していく。  
その後もメモリ使用量が増え続け、システムが何をするにもメモリが足りずに動けなくなった状態をOOMと呼ぶ。

### OOM Killer

システムがOOMに陥った場合、適当なプロセス（主に一番メモリを私用しているプロセス）を選んで強制終了することでメモリ領域を強制的に確保しようとする機能。

### メモリはいつ確保される？

- プロセス生成時（3.プロセス管理参照）
- プロセス生成後、追加で動的にメモリを割り当てるとき

### 動的にメモリを割り当てる

動的なメモリ確保には、プロセスに対してKernelにメモリ獲得用のシステムコールを発行して、メモリ割り当て要求を出す必要がある。
ただし、そんな簡単なメモリの動的確保には次のような問題がある。

- メモリの断片化  
  当たり前すぎの省略
- 別用途のメモリにアクセス可  
  単純な仕組みとして、別のプロセスが使っているアドレスを番地指定すればアクセスできるようでは、データの漏洩や破壊のリスクがあります。
- マルチプロセスの扱いが困難  
  複数のプロセスを同時に動かす場合、同じプログラムをもう一つ動かしてメモリにマップする際に問題が生じる。  
  PG1とPG2は置かれているメモリがまず違うので番地指定では正しくメモリを読み取ることができないからだ。

### 仮想記憶

現在のCPUは便利なもので、そのメモリ問題を解決するために「仮想記憶」機能が搭載されている。  
もちろん、Linuxもそれを使っている。  
仮想記憶は、システムメモリに直接的なアクセスを掛けるのではなく、仮想アドレスを使って間接的にアクセスを掛けようという仕組みである。

- 仮想アドレス: プロセスから見えるメモリのアドレス
- 物理アドレス: 実際に搭載されているメモリのアドレス
- アドレス空間: アドレスによってアクセス可能な範囲

### ページテーブル

仮想アドレスで物理アドレスにはアクセスできないので、それらを相互変換する機能が必要となる。  
それが、Kernelのメモリ内に保存されている**ページテーブル**と呼ばれる機能である。  

- ページ: 仮想記憶上でメモリを管理するための単位。メモリ変換もこの単位で行われる。
  > サイズはCPUのアーキテクチャに依存する。x86_64なら4KBである。
- ページテーブルエントリ: ページテーブル中の１ページに対応するデータのこと。仮想と物理の対応表が入っている。

仮想アドレスにアクセスすると、CPUは**カーネルを介さずに**、自動的にページテーブルの内容を参照して、対応する物理メモリアドレスへ変換する。
> おい、mjk。勝手にやるんだ……。

### 未対応アドレスへのアクセス

仮想アドレス空間の大きさは固定である。その中で、どの仮想アドレスと物理アドレスが結びついているかを管理している。  
物理アドレスが紐づいていない仮想アドレスにアクセスすると、CPU上で**ページフォールト**という割込みが発生する。このページフォールトによって、実行中の命令が中断されて、カーネル内の**ページフォールトハンドラ**が動き出す。  
カーネルはページフォールトハンドラにおいて、プロセスのメモリアクセスが不正であることを検知し、SIGSEVというシグナルを用いてプロセスに通知する。

### 上位レイヤによるメモリ割り当て

C言語のプログラムから`malloc`を呼び出してメモリを確保するプログラムがあるとする。  
Linux環境の`malloc`は最終的には`mmap`を呼び出してKernelにメモリを要求している。  
`malloc`はバイト単位でメモリを獲得するのに対して、`mmap`はページ単位でメモリを獲得する。  
バイト単位のメモリを獲得するために、glibcは事前に`mmap`システムコールでKernelから大きなメモリ領域を要求してプールしておき、`malloc`発行時にその領域から該当サイズ分を切り出して渡している。ページが枯渇した段階で、新たに`mmap`を発行して新しいメモリ領域を獲得する作りになっている。

### メモリ使用量が違う？

システム側から見たプロセスのメモリ使用量は`mmap`で要求されたページ単位のサイズになる。  
しかし、プロセス側から見たメモリの使用量は実際に`malloc`で獲得したバイト単位のサイズになる。  
この差があるため、基本的にはシステム側から見たメモリ使用量の方が大きい。

### 問題の解決

- メモリの断片化  
  物理メモリで必要なところを切り取って一枚の仮想アドレス表にするので断片化は起きない。  
  > え？いや、物理メモリが断片化してるけど、それは「起きない」って言えるの？？
- 別用途のメモリにアクセス可  
  仮想アドレス空間はプロセスごとに生成されるため、別プロセスから参照されることが無い。  
  カーネルのメモリはすべての仮想アドレス空間にマップされてしまっているが、カーネルモードの時のみアクセスできる仕組みになっているため、問題は起きない。
- マルチプロセスの扱いが困難  
  なんども言うが、プロセスごとに仮想アドレス空間が存在するためバッティングすることはない。

### 仮想記憶の応用

仮想記憶によって次のような機能が実現された。

- ファイルマップ
- デマンドページング
- コピーオンライト方式の高速なプロセス生成
- スワップ
- 階層型ページテーブル
- ヒュージページ

## 6.記憶階層

## 7.ファイルシステム

## 8.ストレージデバイス
